
===== app/layout.tsx =====

import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({ variable: "--font-geist-sans", subsets: ["latin"] });
const geistMono = Geist_Mono({ variable: "--font-geist-mono", subsets: ["latin"] });

export const metadata: Metadata = {
  title: "AI G√©n√©rateur de Combinaisons",
  description: "G√©n√©ration par blocs, v√©rification et analyse des combinaisons.",
};

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="fr">
      <body className={`${geistSans.variable} ${geistMono.variable} antialiased min-h-screen bg-[var(--bg)]`}>
        {children}
      </body>
    </html>
  );
}

===== app/globals.css =====

@tailwind base;
@tailwind components;
@tailwind utilities;

:root { --bg: #ffffff; }

html, body { height: 100%; }
body { background: var(--bg); margin: 50; }

===== app/page.tsx =====

"use client";

import { useState } from "react";
import MenuPrincipal from "../components/MenuPrincipal";
import GenerateurGb from "../components/GenerateurGb";
import VerificationCombinaison from "../components/VerificationCombinaison";
import VerificationBlocs from "../components/VerificationBlocs";

type Action = "" | "Gb" | "V" | "Vb";
type LId = "1" | "2" | "3";

export default function Page() {
  // Accueil par d√©faut (action vide) + loterie contr√¥l√©e ici
  const [action, setAction] = useState<Action>("");
  const [loterieId, setLoterieId] = useState<LId>("2");

  const renderContent = () => {
    switch (action) {
      case "Gb":
        return <GenerateurGb loterieId={loterieId} />;
      case "V":
        return <VerificationCombinaison loterieId={loterieId} />;
      case "Vb":
        return <VerificationBlocs loterieId={loterieId} />;
      default:
        return null; // accueil: seulement le menu
    }
  };

  return (
    <main className="min-h-screen flex flex-col items-center p-6 space-y-6">
      <h1 className="text-3xl font-bold">üé≤ AI G√©n√©rateur de Combinaisons</h1>

      {/* Le menu contr√¥le TOUT (loterie + action). */}
      <MenuPrincipal
        loterieId={loterieId}
        onChangeLoterie={(id) => {
          setLoterieId(id);
          setAction(""); // changer de loterie => retour accueil
        }}
        action={action as Exclude<Action, ""> as "Gb" | "V" | "Vb"}
        onChangeAction={(a) => setAction(a)}
      />

      {renderContent()}

      {action !== "" ? (
        <button
          type="button"
          className="border rounded px-3 py-1 text-xs"
          onClick={() => setAction("")}
        >
          ‚¨ÖÔ∏è Accueil
        </button>
      ) : null}
    </main>
  );
}

===== components/MenuPrincipal.tsx =====

"use client";

type LId = "1" | "2" | "3";
type Act = "Gb" | "V" | "Vb";

type Props = {
  loterieId: LId;
  onChangeLoterie: (id: LId) => void;
  action: Act | "";
  onChangeAction: (action: Act) => void;
};

export default function MenuPrincipal({
  loterieId,
  onChangeLoterie,
  action,
  onChangeAction,
}: Props) {
  return (
    <div className="border rounded-lg p-3 space-y-3 text-xs w-full max-w-sm text-center">
      <div className="font-semibold">üéØ Menu principal</div>

      <div className="flex items-center justify-center gap-2">
        <label htmlFor="loterie" className="whitespace-nowrap">
          Loterie
        </label>
        <select
          id="loterie"
          value={loterieId}
          onChange={(e) => onChangeLoterie(e.target.value as LId)}
          className="border rounded px-2 py-1 text-xs"
        >
          <option value="1">Grande Vie</option>
          <option value="2">Lotto Max</option>
          <option value="3">Lotto 6/49</option>
        </select>
      </div>

      <div className="flex flex-col gap-1.5">
        <button
          type="button"
          aria-pressed={action === "Gb"}
          onClick={() => onChangeAction("Gb")}
          className={`px-2 py-1 rounded border text-xs ${
            action === "Gb" ? "bg-gray-100" : ""
          }`}
        >
          (Gb) G√©n√©ration par blocs
        </button>
        <button
          type="button"
          aria-pressed={action === "V"}
          onClick={() => onChangeAction("V")}
          className={`px-2 py-1 rounded border text-xs ${
            action === "V" ? "bg-gray-100" : ""
          }`}
        >
          (V) V√©rifier si combinaisons d√©j√† tir√©es
        </button>
        <button
          type="button"
          aria-pressed={action === "Vb"}
          onClick={() => onChangeAction("Vb")}
          className={`px-2 py-1 rounded border text-xs ${
            action === "Vb" ? "bg-gray-100" : ""
          }`}
        >
          (Vb) V√©rifier bloc
        </button>
      </div>

      <div className="text-[11px] text-gray-600">
        Option s√©lectionn√©e :{" "}
        <strong>{action === "" ? "Accueil" : action}</strong>
      </div>
    </div>
  );
}

===== components/GenerateurGb.tsx =====

"use client";

import { useMemo, useState } from "react";

type Props = { loterieId: "1" | "2" | "3" };

type Combinaison = {
  bloc: number;
  combinaison: number[];
  etoile: boolean;
};

type ApiSuccess = {
  ok: true;
  data: Combinaison[];
  echo?: { loterie: string; blocs: number };
  source?: string;
};
type ApiError = { ok: false; error: string; [k: string]: unknown };
type ApiResponse = ApiSuccess | ApiError;

/* ---------- Config loteries ---------- */
const CFG = {
  "1": { name: "Grande Vie", baseCount: 9 },
  "2": { name: "Lotto Max",  baseCount: 7 },
  "3": { name: "Lotto 6/49", baseCount: 8 },
} as const;

const LOT_NAMES: Record<Props["loterieId"], string> = {
  "1": CFG["1"].name,
  "2": CFG["2"].name,
  "3": CFG["3"].name,
};

const fmtComb = (nums: number[]) => nums.map(n => String(n).padStart(2, "0")).join(" ");
const fmtList = (nums: number[]) => nums.map(n => String(n).padStart(2, "0")).join(", ");

/* ---------- Synth√®se ---------- */
function summarizeBlock(base: number[][], star?: number[]) {
  const counts = new Map<number, number>();
  for (const c of base) for (const n of c) counts.set(n, (counts.get(n) || 0) + 1);
  const doublons = [...counts.entries()].filter(([, c]) => c > 1).map(([n]) => n).sort((a, b) => a - b);

  const baseSet = new Set<number>(base.flat());
  const reutilises = (star ?? []).filter(n => baseSet.has(n)).sort((a, b) => a - b);
  const nouveaux  = (star ?? []).filter(n => !baseSet.has(n)).sort((a, b) => a - b);

  return { doublons, reutilises, nouveaux };
}

/* ---------- Groupement robuste ---------- */
function groupCombinaisons(
  data: Combinaison[],
  requestedBlocs: number,
  baseCount: number
): { blocNo: number; base: number[][]; star?: number[] }[] {
  if (!data?.length) return [];

  // 1) Essai par num√©ro de bloc (si >= 2 distincts)
  const byBloc = new Map<number, { base: number[][]; stars: number[][] }>();
  for (const item of data) {
    const key = Number.isFinite(item.bloc) && item.bloc > 0 ? item.bloc : 1;
    const entry = byBloc.get(key) ?? { base: [], stars: [] };
    (item.etoile ? entry.stars : entry.base).push(item.combinaison);
    byBloc.set(key, entry);
  }
  const distinct = [...byBloc.keys()].sort((a, b) => a - b);
  if (distinct.length >= 2) {
    return distinct.map(k => ({
      blocNo: k,
      base: byBloc.get(k)!.base,
      star: byBloc.get(k)!.stars[0],
    }));
  }

  // 2) D√©coupe s√©quentielle ‚Äî on forme un bloc d√®s qu'on a baseCount bases;
  //    on prend la prochaine √©toile si elle vient juste apr√®s, sinon bloc sans √©toile.
  const out: { blocNo: number; base: number[][]; star?: number[] }[] = [];
  let i = 0, blocNo = 1;
  while (i < data.length) {
    const base: number[][] = [];
    // collecter baseCount lignes de base (en sautant les √©toiles)
    while (i < data.length && base.length < baseCount) {
      if (!data[i].etoile) base.push(data[i].combinaison);
      i++;
    }

    // regarder si la prochaine ligne est une √©toile (li√©e √† ce bloc)
    let star: number[] | undefined;
    if (i < data.length && data[i].etoile) {
      star = data[i].combinaison;
      i++;
    }

    if (base.length > 0 || star) {
      out.push({ blocNo: blocNo++, base, star });
    } else {
      // anti-boucle si bruit
      i++;
    }
  }

  // Si malgr√© tout on a 1 seul bloc mais l'utilisateur en demande plusieurs,
  // on ne "casse" pas arbitrairement : on laisse 1 bloc (source ne fournit
  // probablement pas assez de lignes pour plus d'un bloc).
  return out;
}

/* ======================== Composant ======================== */
export default function GenerateurGb({ loterieId }: Props) {
  const [resultat, setResultat] = useState<ApiResponse | null>(null);
  const [loading, setLoading]   = useState(false);
  const [err, setErr]           = useState<string | null>(null);
  const [nbBlocs, setNbBlocs]   = useState(1);

  const loterieName = LOT_NAMES[loterieId];
  const baseCount   = CFG[loterieId].baseCount;

  const generer = async () => {
    setLoading(true);
    setErr(null);
    setResultat(null);
    try {
      const blocs = Math.max(1, Math.min(30, nbBlocs));
      const r = await fetch("/api/generer", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          loterie: loterieId,
          mode: "Gb",
          blocs,          // formats tol√©r√©s par le backend
          nBlocs: blocs,
          n_blocs: blocs,
        }),
      });
      const json: ApiResponse = await r.json();
      setResultat(json);
    } catch (e) {
      setErr(e instanceof Error ? e.message : String(e));
    } finally {
      setLoading(false);
    }
  };

  const grouped = useMemo(() => {
    if (!resultat || !("ok" in resultat) || !resultat.ok) return [];
    const buckets = groupCombinaisons(resultat.data, nbBlocs, baseCount);
    return buckets.map(({ blocNo, base, star }) => {
      const { doublons, reutilises, nouveaux } = summarizeBlock(base, star);
      const lines = base.map(c => fmtComb(c)).join("\n") + (star ? `\n${fmtComb(star)} ‚òÖ` : "");
      return { blocNo, lines, doublons, reutilises, nouveaux };
    });
  }, [resultat, nbBlocs, baseCount]);

  return (
    <div className="border rounded-lg p-2 sm:p-3 space-y-2 text-[13px] w-fit max-w-full mx-auto">
      <div className="flex items-center justify-between">
        <div className="font-semibold text-[13px]">
          Gb ‚Äî G√©n√©ration par blocs couvrants (+ √©toile) / {loterieName}
        </div>
      </div>

      <div className="flex items-center gap-2 text-[12px]">
        <label className="whitespace-nowrap">Nombre de blocs</label>
        <input
          type="number"
          min={1}
          max={30}
          value={nbBlocs}
          onChange={(e) => setNbBlocs(Math.max(1, Math.min(30, parseInt(e.target.value || "1", 10))))}
          className="w-20 rounded-lg border px-2 py-1 text-center"
        />
        <button onClick={generer} disabled={loading} className="rounded-lg px-2.5 py-1.5 border text-[12px] disabled:opacity-60">
          {loading ? "G√©n√©ration..." : "G√©n√©rer"}
        </button>
        <button onClick={() => { setResultat(null); setErr(null); }} className="rounded-lg px-2.5 py-1.5 border text-[12px]">
          R√©initialiser
        </button>
      </div>

      {err && <pre className="text-red-600 text-[12px] whitespace-pre-wrap w-fit">{err}</pre>}

      {resultat !== null && "ok" in resultat && resultat.ok && resultat.echo && (
        <div className="text-[12px] text-gray-600 w-fit">
          {resultat.echo.loterie} ‚Äî {resultat.echo.blocs} blocs g√©n√©r√©s ({resultat.data.length} combis)
        </div>
      )}

      {resultat !== null && "ok" in resultat && resultat.ok && (
  <div className="flex flex-col gap-3 max-h-[70vh] overflow-y-auto pr-2">
    {grouped.map((b, idx) => {
      // petit r√©sum√© pour le header
      const resume =
        (b.reutilises.length ? `R√©utilis√©s: ${b.reutilises.length}` : "R√©utilis√©s: 0") +
        " ¬∑ " +
        (b.nouveaux.length ? `Nouveaux: ${b.nouveaux.length}` : "Nouveaux: 0") +
        (b.doublons.length ? ` ¬∑ Doublons: ${b.doublons.length}` : "");

      return (
        <details
          key={b.blocNo}
          className="group w-full border rounded-lg bg-white/70 shadow-sm"
          {...(idx === 0 ? { open: true } : {})} // ouvre le 1er bloc par d√©faut
        >
          <summary className="flex items-center justify-between gap-2 cursor-pointer select-none px-3 py-2 text-[12px] font-semibold">
            <span>Bloc {b.blocNo}</span>
            <span className="text-gray-600 font-normal">
              {resume}
            </span>
          </summary>

          <div className="px-3 pb-3">
            <pre className="font-mono text-[11px] leading-[1.25] bg-gray-50 border rounded p-2 whitespace-pre w-full overflow-x-auto">
{b.lines}
            </pre>

            <div className="mt-2 space-y-1 text-[11px]">
              <div>
                {b.doublons.length === 0
                  ? "üëç Aucun doublon d√©tect√© dans les combinaisons de base."
                  : `‚ö†Ô∏è Doublons d√©tect√©s dans les combinaisons de base : [${fmtList(b.doublons)}]`}
              </div>
              <div>
                üî∑ Num√©ros r√©utilis√©s dans la combinaison √©toile : [
                {b.reutilises.length ? fmtList(b.reutilises) : "aucun"}]
              </div>
              <div>
                ‚ö†Ô∏è Num√©ros nouveaux (restants) dans la combinaison √©toile : [
                {b.nouveaux.length ? fmtList(b.nouveaux) : "aucun"}]
              </div>
            </div>
          </div>
        </details>
      );
    })}
  </div>
)}

      {resultat !== null && "ok" in resultat && resultat.ok === false && (
        <pre className="text-red-600 text-[12px] whitespace-pre-wrap w-fit">{resultat.error}</pre>
      )}
    </div>
  );
}
===== components/VerificationCombinaison.tsx =====

"use client";

import { useEffect, useMemo, useState } from "react";

const CFG = {
  "1": { name: "Grande Vie", numsPerComb: 5 },
  "2": { name: "Lotto Max",  numsPerComb: 7 },
  "3": { name: "Lotto 6/49", numsPerComb: 6 },
} as const;
type LId = keyof typeof CFG;

type ApiOk  = { ok: true;  data?: unknown; [k: string]: unknown };
type ApiErr = { ok: false; error: string; [k: string]: unknown };
type ApiResp = ApiOk | ApiErr;

function isRecord(v: unknown): v is Record<string, unknown> {
  return typeof v === "object" && v !== null && !Array.isArray(v);
}

function parseLine(line: string, expected: number): number[] {
  const nums = line
    .replace(/[;,]+/g, " ")
    .split(/\s+/)
    .filter(Boolean)
    .map((t) => parseInt(t, 10))
    .filter(Number.isFinite);
  if (nums.length !== expected) throw new Error(`Chaque ligne doit contenir ${expected} nombres. ¬´ ${line} ¬ª`);
  return nums.sort((a, b) => a - b);
}
const fmtComb = (nums: number[]) => nums.map((n) => String(n).padStart(2, "0")).join(" ");

/** Interpr√®te des formats de r√©ponse vari√©s ({found|existe|occurrences|count}...) */
function interpret(api: unknown): { found: boolean } {
  if (isRecord(api)) {
    const a = api as Record<string, unknown>;
    if (typeof a.found === "boolean") return { found: a.found };
    if (typeof a.existe === "boolean") return { found: a.existe };
    if (typeof a.occurrences === "number") return { found: a.occurrences > 0 };
    if (typeof a.count === "number") return { found: a.count > 0 };
  }
  const text = typeof api === "string" ? api : JSON.stringify(api);
  if (/AUCUNE\s+OCCURRENCE/i.test(text)) return { found: false };
  if (/OCCURRENCE|TIR√âE|TIRAGE/i.test(text)) return { found: true };
  return { found: false };
}

export default function VerifierCombinaisons({ loterieId }: { loterieId: LId }) {
  const cfg = CFG[loterieId];

  const [text, setText] = useState("");
  const [rows, setRows] = useState<{ comb: number[]; ok?: boolean; error?: string }[]>([]);
  const [loading, setLoading] = useState(false);
  const [err, setErr] = useState<string | null>(null);
  const [showEditor, setShowEditor] = useState(true);

  useEffect(() => {
    setShowEditor(true);
    setRows([]);
    setErr(null);
    setText("");
  }, [loterieId]);

  const placeholder = useMemo(() => {
    return [
      Array.from({ length: cfg.numsPerComb }, (_, i) => i + 1).join(" "),
      Array.from({ length: cfg.numsPerComb }, (_, i) => i + 11).join(" "),
      Array.from({ length: cfg.numsPerComb }, (_, i) => i + 21).join(" "),
    ].join("\n");
  }, [cfg.numsPerComb]);

  async function onVerify() {
    setErr(null);
    setRows([]);
    setLoading(true);
    try {
      const lines = text.split(/\r?\n/).map((l) => l.trim()).filter(Boolean);
      if (!lines.length) throw new Error("Collez une ou plusieurs combinaisons (une par ligne).");
      const combs = lines.map((l) => parseLine(l, cfg.numsPerComb));

      const results: { comb: number[]; ok?: boolean; error?: string }[] = [];
      for (const comb of combs) {
        try {
          const r = await fetch("/api/verifier", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ loterie: loterieId, combinaison: comb }),
          });
          const txt = await r.text();

          let data: ApiResp;
          try {
            const parsed = JSON.parse(txt) as unknown;
            if (isRecord(parsed) && "ok" in parsed) {
              data = parsed as ApiResp;
            } else {
              data = { ok: true, data: parsed } as ApiOk;
            }
          } catch {
            data = { ok: true, data: txt } as ApiOk;
          }

          if (!("ok" in data) || data.ok !== true) {
            const errMsg =
              (isRecord(data) && typeof (data as ApiErr).error === "string")
                ? (data as ApiErr).error
                : `Erreur ${r.status}`;
            results.push({ comb, error: errMsg });
          } else {
            const payload = (data as ApiOk).data ?? data;
            const { found } = interpret(payload);
            results.push({ comb, ok: found });
          }
        } catch (e: unknown) {
          const err = e instanceof Error ? e.message : String(e);
          results.push({ comb, error: err || "Erreur" });
        }
      }

      setRows(results);
      setShowEditor(false);
    } catch (e: unknown) {
      const msg = e instanceof Error ? e.message : String(e);
      setErr(msg || "Erreur");
    } finally {
      setLoading(false);
    }
  }

  function onReset() {
    setText("");
    setRows([]);
    setErr(null);
    setShowEditor(true);
  }

  const deja   = rows.filter(r => r.error == null && r.ok === true);
  const jamais = rows.filter(r => r.error == null && r.ok === false);
  const fails  = rows.filter(r => r.error != null);

  return (
    <div className="rounded-lg border p-2 sm:p-3 space-y-2 text-[13px]">
      {/* Titre + toggle */}
      <div className="flex items-center justify-between">
        <h3 className="font-semibold text-[13px]">
          V ‚Äî V√©rifier si combinaisons d√©j√† tir√©es / {cfg.name}
        </h3>
        <button
          type="button"
          onClick={() => setShowEditor(v => !v)}
          className="text-[12px] underline decoration-dotted"
        >
          {showEditor ? "Masquer" : "‚úé Saisir les combinaisons"}
        </button>
      </div>

      {/* √âditeur compact (seulement si visible) */}
      {showEditor && (
        <>
          <textarea
            value={text}
            onChange={(e) => setText(e.target.value)}
            rows={5}
            placeholder={placeholder}
            className="w-full border rounded p-2 font-mono text-[12px] leading-[1.2]"
          />
          <div className="flex items-center gap-2">
            <button
              onClick={onVerify}
              disabled={loading || !text.trim()}
              className="px-2.5 py-1.5 rounded-lg border text-[12px]"
            >
              {loading ? "..." : "V√©rifier"}
            </button>
            <button onClick={onReset} className="px-2.5 py-1.5 rounded-lg border text-[12px]">
              R√©initialiser
            </button>
          </div>
        </>
      )}

      {err && <div className="text-red-600 text-[12px]">{err}</div>}

      {/* R√©sultats ultra-compacts : titres dans les coins + barre verticale */}
      {rows.length > 0 && (
        <div className="border rounded p-2 font-mono text-[12px] leading-tight">
          {/* titres en coins */}
          <div className="grid grid-cols-2 items-start">
            <div className="font-semibold">D√©j√† tir√©es : {deja.length}</div>
            <div className="font-semibold text-right">Jamais tir√©es : {jamais.length}</div>
          </div>

          {/* deux colonnes rapproch√©es s√©par√©es par une fine barre */}
          <div className="mt-1 grid grid-cols-2 divide-x divide-gray-300">
            <div className="pr-2 space-y-0.5">
              {deja.length === 0 ? (
                <div className="text-gray-500">‚Äî</div>
              ) : (
                deja.map((r, i) => <div key={`d-${i}`}>{fmtComb(r.comb)}</div>)
              )}
            </div>
            <div className="pl-2 space-y-0.5">
              {jamais.length === 0 ? (
                <div className="text-gray-500">‚Äî</div>
              ) : (
                jamais.map((r, i) => <div key={`j-${i}`}>{fmtComb(r.comb)}</div>)
              )}
            </div>
          </div>

          {/* erreurs (si besoin), toujours compact */}
          {fails.length > 0 && (
            <div className="mt-2 text-[11px]">
              <div className="font-semibold mb-1">Erreurs : {fails.length}</div>
              <div className="space-y-0.5">
                {fails.map((r, i) => (
                  <div key={`e-${i}`} className="flex gap-2">
                    <div className="w-[200px]">{fmtComb(r.comb)}</div>
                    <div>‚ö†Ô∏è {r.error}</div>
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>
      )}
    </div>
  );
}

===== components/VerificationBlocs.tsx =====

"use client";

import { useEffect, useMemo, useState } from "react";

type VerifierBlocSuccess = {
  ok: true;
  data: {
    valide: boolean;
    erreurs: string[];
    details: Array<Record<string, unknown>>;
  };
};
type ApiError = { ok: false; error: string; [k: string]: unknown };
type ApiResponse = VerifierBlocSuccess | ApiError;

const CFG = {
  "1": { name: "Grande Vie", numsPerComb: 5, baseCount: 9,  somme: [80, 179]  as [number, number] },
  "2": { name: "Lotto Max",  numsPerComb: 7, baseCount: 7,  somme: [140, 219] as [number, number] },
  "3": { name: "Lotto 6/49", numsPerComb: 6, baseCount: 8,  somme: [100, 199] as [number, number] },
} as const;

const KEYS = [
  "Pair/Impair", "Petit/Grand", "S√©ries", "Dizaines",
  "Fin identique", "Diversit√© finales", "Symboliques", "Somme",
] as const;

const TICK = "‚úî";
const CROSS = "‚úó";

/* ---------- helpers ---------- */
const fmtComb = (nums: number[]) => nums.map((n) => n.toString().padStart(2, "0")).join(" ");
const fmtList = (nums: number[]) => nums.map((n) => n.toString().padStart(2, "0")).join(", ");
const padRight = (s: string, w: number) => s + " ".repeat(Math.max(0, w - s.length));

function buildAsciiTable(rows: Array<{ comb: number[]; checks: Record<string, boolean>; sommeRange: [number, number]; }>) {
  const sommeLabel = `Somme : ${rows[0]?.sommeRange?.[0] ?? "?"} - ${rows[0]?.sommeRange?.[1] ?? "?"}`;

  // ‚¨áÔ∏è colonne "Combinaison" uniquement (pas de No.), et on garde tous les crit√®res + Somme
  const headers = ["Combinaison", ...KEYS.slice(0, -1), sommeLabel];

  const data = rows.map((r) => {
    const sum = r.comb.reduce((a, b) => a + b, 0);
    return [
      fmtComb(r.comb),
      ...KEYS.slice(0, -1).map((k) => (r.checks[k] ? TICK : CROSS)),
      `${r.checks["Somme"] ? TICK : CROSS} (${sum})`,
    ];
  });

  const widths = headers.map((_, c) => Math.max(headers[c].length, ...(data.map(row => row[c].length))));
  const sep  = widths.map((w) => "-".repeat(w)).join(" | ");
  const line = (cols: string[]) => cols.map((s, i) => padRight(s, widths[i])).join(" | ");

  return [line(headers), sep, ...data.map(line)].join("\n");
}

function parseBlockText(text: string, numsPerComb: number) {
  const lines = text.split(/\r?\n/).map((l) => l.trim()).filter(Boolean);
  const block: number[][] = [];
  for (const l of lines) {
    const nums = l.replace(/[;,]+/g, " ").split(/\s+/).map((t) => parseInt(t, 10)).filter(Number.isFinite);
    if (nums.length !== numsPerComb) throw new Error(`Chaque ligne doit avoir ${numsPerComb} nombres. Ligne : ¬´ ${l} ¬ª`);
    block.push([...nums].sort((a, b) => a - b));
  }
  return block;
}

/* ======================== composant Vb densifi√© ======================== */
export default function VerificationBlocs({ loterieId }: { loterieId: "1" | "2" | "3" }) {
  const cfg = CFG[loterieId];
  const baseCount = cfg.baseCount;
  const numsPerComb = cfg.numsPerComb;
  const expectedTotal = baseCount + 1; // base + √©toile (derni√®re ligne)

  const [showEditor, setShowEditor] = useState(true); // propose la saisie au chargement/changement loterie
  const [blocText, setBlocText] = useState("");
  const [ascii, setAscii] = useState("");
  const [err, setErr] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);

  // quand la loterie change, on repart propre
  useEffect(() => {
    setShowEditor(true);
    setAscii("");
    setErr(null);
    setBlocText("");
  }, [loterieId]);

  const placeholder = useMemo(
    () =>
      Array.from({ length: expectedTotal }, (_, i) =>
        Array.from({ length: numsPerComb }, (_, j) => i * numsPerComb + j + 1).join(" ")
      ).join("\n"),
    [expectedTotal, numsPerComb]
  );

  const submit = async () => {
    setAscii(""); setErr(null); setLoading(true);
    try {
      const parsed = parseBlockText(blocText, numsPerComb);
      if (parsed.length !== expectedTotal) throw new Error(`Il faut ${expectedTotal} lignes (base ${baseCount} + 1 √©toile).`);

      const etoileIndex = parsed.length - 1; // √©toile = derni√®re ligne

      // --- API : crit√®res ‚úî/‚úó
      const r = await fetch("/api/verifier-bloc", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ loterie: loterieId, bloc: parsed, etoileIndex }),
      });
      const text = await r.text();
      let data: ApiResponse;
      try { data = JSON.parse(text); } catch { throw new Error("R√©ponse du serveur invalide."); }
      if (!data.ok) throw new Error(data.error || "Erreur serveur");

      // --- rows pour le tableau
      const rows = data.data.details.map((obj, i) => {
        const comb = Array.isArray(obj["Combinaison"]) ? (obj["Combinaison"] as number[]) : parsed[i];
        const checks: Record<string, boolean> = {};
        for (const k of KEYS) checks[k] = typeof obj[k] === "boolean" ? (obj[k] as boolean) : false;
        return { comb, checks, sommeRange: cfg.somme };
      });

      // --- calcul synth√®se (doublons / r√©utilis√©s / nouveaux) c√¥t√© front
      const baseIdxs  = parsed.map((_, i) => i).filter((i) => i !== etoileIndex);
      const baseCombs = baseIdxs.map((i) => parsed[i]);
      const starComb  = parsed[etoileIndex];

      const counts = new Map<number, number>();
      for (const comb of baseCombs) for (const n of comb) counts.set(n, (counts.get(n) || 0) + 1);
      const doublons = [...counts.entries()].filter(([, c]) => c > 1).map(([n]) => n).sort((a, b) => a - b);

      const baseSet = new Set<number>(baseCombs.flat());
      const reutilises = starComb.filter((n) => baseSet.has(n)).sort((a, b) => a - b);
      const nouveaux  = starComb.filter((n) => !baseSet.has(n)).sort((a, b) => a - b);

      // --- rendu ASCII compact
      const blocHead = `Bloc 1 :`;
      const table    = buildAsciiTable(rows);
      const line1    = doublons.length === 0
        ? "üëç Aucun doublon d√©tect√© dans les combinaisons de base."
        : `‚ö†Ô∏è Doublons d√©tect√©s dans les combinaisons de base : [${fmtList(doublons)}]`;
      const line2    = `üî∑ Num√©ros r√©utilis√©s dans la combinaison √©toile : [${fmtList(reutilises)}]`;
      const line3    = `‚ö†Ô∏è Num√©ros nouveaux (restants) dans la combinaison √©toile : [${fmtList(nouveaux)}]`;

      setAscii(`${blocHead}\n${table}\n\n${line1}\n\n${line2}\n\n${line3}`);
      setShowEditor(false); // on masque apr√®s succ√®s (comme V)
    } catch (e) {
      setErr(e instanceof Error ? e.message : String(e));
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="rounded-lg border p-2 sm:p-3 space-y-2 text-[13px]">
      {/* En-t√™te + toggle */}
      <div className="flex items-center justify-between">
        <h3 className="font-semibold text-[13px]">
          Vb ‚Äî V√©rifier couverture de blocs / {cfg.name} : {baseCount} + 1*
        </h3>
        <button
          type="button"
          onClick={() => setShowEditor((v) => !v)}
          className="text-[12px] underline decoration-dotted"
        >
          {showEditor ? "Masquer le bloc" : "‚úé Saisir le bloc"}
        </button>
      </div>

      {/* Toolbar compacte : V√©rifier + ‚ÄúNb attendu‚Äù en pill */}
      <div className="flex items-center justify-between text-[12px]">
        <div className="flex items-center gap-2">
          <button
            onClick={submit}
            disabled={loading || !blocText.trim()}
            className="px-2.5 py-1.5 rounded-lg border"
            title={blocText.trim() ? "V√©rifier" : "Collez un bloc (via Saisir le bloc) puis v√©rifiez"}
          >
            {loading ? "..." : "V√©rifier"}
          </button>
          <div className="px-2.5 py-1.5 rounded-lg border bg-white text-gray-700 select-none">
            Nb attendu&nbsp;: {expectedTotal}
          </div>
        </div>
      </div>

      {/* √âditeur (compact, visible √† la demande) */}
      {showEditor && (
        <textarea
          value={blocText}
          onChange={(e) => setBlocText(e.target.value)}
          rows={Math.max(6, expectedTotal)}
          placeholder={placeholder}
          className="w-full border rounded p-2 font-mono text-[12px] leading-[1.2]"
        />
      )}

      {err && <div className="text-red-600 text-[12px]">{err}</div>}

      {/* Tableau ASCII + synth√®se ‚Äî densifi√©s */}
      {ascii && (
        <pre className="font-mono text-[11px] leading-[1.25] bg-gray-50 border rounded p-2 whitespace-pre overflow-x-auto">
{ascii}
        </pre>
      )}
    </div>
  );
}

===== postcss.config.js =====

module.exports = { plugins: { "@tailwindcss/postcss": {} } }

===== tailwind.config.ts =====

export default {
  content: ["./app/**/*.{js,ts,jsx,tsx}", "./components/**/*.{js,ts,jsx,tsx}"],
  theme: { extend: {} },
  plugins: [],
}

===== next.config.mjs =====

/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  // Si tu veux configurer Turbopack plus tard:
  // turbopack: { /* rules, resolve, etc. */ },
};

export default nextConfig;
===== package.json =====

{
  "name": "frontend-loto",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "lightningcss": "1.27.0",
    "next": "15.5.0",
    "react": "19.1.0",
    "react-dom": "19.1.0"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "autoprefixer": "^10.4.21",
    "eslint": "^9",
    "eslint-config-next": "15.5.0",
    "postcss": "^8.5.6",
    "tailwindcss": "^4.1.12",
    "typescript": "^5"
  }
}
